import sys
import math
import numpy as np
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout,
    QPushButton, QLabel, QLineEdit, QCheckBox, QFrame
)
from PyQt5.QtGui import QMatrix4x4
from PyQt5.QtCore import QTimer
import pyqtgraph.opengl as gl

# ============================================================
# CHASSIS / TURRET
# ============================================================
CHASSIS = {"Lx": 304.8, "Ly": 245.0, "Lz": 120.0}
TURRET  = {"radius": 45.0, "height": 18.0}

BASE_HEIGHT             = 20.0
BASE_TO_SHOULDER_OFFSET = 0.0

# Arm link lengths (mm)
L1 = 152.4   # upper arm
L2 = 228.6   # forearm
L3 = 40.0    # wrist-to-claw-mount

# Claw
CLAW_HINGE_SEP     = 16.0
FINGER_LEN         = 20.0
TIP_ARC_RADIUS     = 5.0
TIP_ARC_PTS        = 10
PINCH_DISTANCE_MM  = 12.0
GRIP_SMOOTH        = 0.12
CLAW_CENTER_OFFSET = FINGER_LEN

# Obstacle half-extents (mm)
OBS_HALF = np.array([25.0, 25.0, 35.0], dtype=float)

# ============================================================
# JOINT LIMITS  â€” each servo is 180Â° total, centred on HOME
#
#  Joint     Home (mid-point)          Range
#  -------   -----------------------   ---------------
#  yaw       0Â°  (straight forward)    -90Â° â€¦ +90Â°
#  shoulder  0Â°  (arm horizontal)      -90Â° â€¦ +90Â°
#  elbow     -90Â° (forearm horiz,      -180Â° â€¦ 0Â°
#             upper-arm vertical)
#  wrist     0Â°  (straight through)    -90Â° â€¦ +90Â°
# ============================================================
JOINT_LIMITS = {
    "yaw":      (math.radians(-90),  math.radians( 90)),
    "shoulder": (math.radians(-90),  math.radians( 90)),
    "elbow":    (math.radians(-180), math.radians(  0)),
    "wrist":    (math.radians(-90),  math.radians( 90)),
}

# Home pose â€” all servos at their mechanical mid-point.
# Elbow home is -90Â° (upper-arm vertical, forearm horizontal).
# Shoulder at +45Â° tilts the upper arm forward so the arm
# extends outward rather than folding back on itself.
# Wrist compensates to keep the tool roughly level: -(45 + -90) = +45Â°
HOME_ANGLES = [
    0.0,               # yaw      =   0Â°  (straight forward)
    math.radians( 45), # shoulder = +45Â°  (upper arm angled forward/up)
    math.radians(-90), # elbow    = -90Â°  (servo mid-point; forearm horizontal)
    math.radians( 45), # wrist    = +45Â°  (keeps tool roughly level)
]

# Warning thresholds (fraction of range used)
WARN_YELLOW = 0.80   # 80 % of range â†’ yellow
WARN_RED    = 0.98   # 98 % of range â†’ red (essentially at limit)

BOX_MARGIN = 3.0
CYL_MARGIN = 8.0

PATH_CHECK_STEPS = 10

VIA_YAW_N      = 7
VIA_SHOULDER_N = 7
VIA_ELBOW_N    = 7


# ============================================================
# Utility
# ============================================================
def clamp(v, lo, hi):
    return max(lo, min(hi, v))

def unit(v):
    n = float(np.linalg.norm(v))
    return v / (n + 1e-9)

def within_limits(yaw, shoulder, elbow, wrist):
    return (JOINT_LIMITS["yaw"][0]      <= yaw      <= JOINT_LIMITS["yaw"][1]      and
            JOINT_LIMITS["shoulder"][0] <= shoulder <= JOINT_LIMITS["shoulder"][1] and
            JOINT_LIMITS["elbow"][0]    <= elbow    <= JOINT_LIMITS["elbow"][1]    and
            JOINT_LIMITS["wrist"][0]    <= wrist    <= JOINT_LIMITS["wrist"][1])

JOINT_HOMES = {
    "yaw":      0.0,
    "shoulder": math.radians( 45),
    "elbow":    math.radians(-90),
    "wrist":    math.radians( 45),
}

def joint_usage_fraction(name, value):
    """How far from HOME is this value, as a fraction of the half-range to the nearest limit."""
    lo, hi   = JOINT_LIMITS[name]
    home     = JOINT_HOMES[name]
    # distance to nearest limit from home position
    half     = min(abs(home - lo), abs(hi - home))
    return abs(value - home) / half if half > 1e-9 else 0.0

def limit_color_style(fraction):
    """Return a Qt stylesheet colour string based on how close to a limit."""
    if fraction >= WARN_RED:
        return "color: #ff3030; font-weight: bold;"
    elif fraction >= WARN_YELLOW:
        return "color: #ffcc00; font-weight: bold;"
    else:
        return "color: #80ff80;"


# ============================================================
# Dynamic geometry
# ============================================================
def get_arm_mount(cp):
    return np.array([cp[0], cp[1], CHASSIS["Lz"]], dtype=float)

def get_deadzone_box(cp):
    return {
        "center": np.array([cp[0], cp[1], CHASSIS["Lz"] / 2.0], dtype=float),
        "size":   np.array([CHASSIS["Lx"] + 2*BOX_MARGIN,
                            CHASSIS["Ly"] + 2*BOX_MARGIN,
                            CHASSIS["Lz"] + 2*BOX_MARGIN], dtype=float)
    }

def get_deadzone_cyl(cp):
    return {
        "center": np.array([cp[0], cp[1], CHASSIS["Lz"]], dtype=float),
        "radius": TURRET["radius"] + CYL_MARGIN,
        "height": TURRET["height"] + 2*CYL_MARGIN
    }


# ============================================================
# Mesh builders
# ============================================================
def make_box_mesh(center, size_xyz, color=(0.3, 0.3, 0.35, 0.6)):
    sx, sy, sz = size_xyz
    cx, cy, cz = center
    x0,x1 = cx-sx/2, cx+sx/2
    y0,y1 = cy-sy/2, cy+sy/2
    z0,z1 = cz-sz/2, cz+sz/2
    verts = np.array([
        [x0,y0,z0],[x1,y0,z0],[x1,y1,z0],[x0,y1,z0],
        [x0,y0,z1],[x1,y0,z1],[x1,y1,z1],[x0,y1,z1],
    ], dtype=float)
    faces = np.array([
        [0,1,2],[0,2,3],[4,6,5],[4,7,6],
        [0,4,5],[0,5,1],[1,5,6],[1,6,2],
        [2,6,7],[2,7,3],[3,7,4],[3,4,0],
    ], dtype=int)
    md   = gl.MeshData(vertexes=verts, faces=faces)
    item = gl.GLMeshItem(meshdata=md, smooth=False, drawFaces=True, drawEdges=True,
                         edgeColor=(1.0, 1.0, 1.0, 1.0))
    item.setColor(color)
    return item

def make_cylinder_mesh(center, radius, height, slices=36, color=(0.45,0.45,0.5,0.7)):
    cx,cy,cz = center;  z0,z1 = cz, cz+height
    angles = np.linspace(0, 2*np.pi, slices, endpoint=False)
    c0 = np.stack([cx+radius*np.cos(angles), cy+radius*np.sin(angles), np.full_like(angles,z0)], axis=1)
    c1 = np.stack([cx+radius*np.cos(angles), cy+radius*np.sin(angles), np.full_like(angles,z1)], axis=1)
    verts = np.vstack([c0, c1, [[cx,cy,z0],[cx,cy,z1]]])
    ic0,ic1 = 2*slices, 2*slices+1
    faces = []
    for i in range(slices):
        j=(i+1)%slices; faces+=[[i,j,slices+j],[i,slices+j,slices+i]]
    for i in range(slices):
        j=(i+1)%slices; faces.append([ic0,j,i])
    for i in range(slices):
        j=(i+1)%slices; faces.append([ic1,slices+i,slices+j])
    md   = gl.MeshData(vertexes=verts, faces=np.array(faces,dtype=int))
    item = gl.GLMeshItem(meshdata=md, smooth=True, drawFaces=True, drawEdges=False)
    item.setColor(color);  return item


# ============================================================
# Collision
# ============================================================
def seg_vs_box(p0, p1, bc, bs):
    mn=bc-bs/2.0; mx=bc+bs/2.0; d=p1-p0; tmin,tmax=0.0,1.0
    for i in range(3):
        if abs(d[i])<1e-9:
            if p0[i]<mn[i] or p0[i]>mx[i]: return False
        else:
            ood=1.0/d[i]; t1=(mn[i]-p0[i])*ood; t2=(mx[i]-p0[i])*ood
            if t1>t2: t1,t2=t2,t1
            tmin=max(tmin,t1); tmax=min(tmax,t2)
            if tmin>tmax: return False
    return True

def seg_vs_cyl(p0, p1, cc, radius, height):
    p0=p0-cc; p1=p1-cc; d=p1-p0
    a=d[0]**2+d[1]**2; b=2*(p0[0]*d[0]+p0[1]*d[1]); c=p0[0]**2+p0[1]**2-radius**2
    if abs(a)<1e-9: return False
    disc=b*b-4*a*c
    if disc<0: return False
    sq=math.sqrt(disc)
    for t in [(-b-sq)/(2*a),(-b+sq)/(2*a)]:
        if 0<=t<=1:
            z=p0[2]+t*d[2]
            if 0<=z<=height: return True
    return False

def pose_collides(pts, chassis_pos, obstacles=()):
    box=get_deadzone_box(chassis_pos); cyl=get_deadzone_cyl(chassis_pos)
    for i in range(2, len(pts)-1):
        a,b=pts[i],pts[i+1]
        if seg_vs_box(a,b,box["center"],box["size"]): return True
        if seg_vs_cyl(a,b,cyl["center"],cyl["radius"],cyl["height"]): return True
        for obs in obstacles:
            if seg_vs_box(a,b,obs["center"],obs["size"]): return True
    return False

def path_collides(ang_a, ang_b, chassis_pos, obstacles):
    for k in range(1, PATH_CHECK_STEPS+1):
        t=k/PATH_CHECK_STEPS
        interp=[ang_a[j]+t*(ang_b[j]-ang_a[j]) for j in range(4)]
        pts=forward_kinematics_world(*interp, chassis_pos)
        if pose_collides(pts, chassis_pos, obstacles): return True
    return False


# ============================================================
# IK + FK
# ============================================================
def solve_ik_wrist_base(x, y, z, elbow_up=True):
    yaw   = math.atan2(y, x)
    r     = math.sqrt(x*x+y*y)
    z_eff = z-BASE_HEIGHT
    d2    = r*r+z_eff*z_eff;  d=math.sqrt(d2)
    if d>L1+L2 or d<abs(L1-L2): return None
    cos_e = clamp((d2-L1*L1-L2*L2)/(2*L1*L2), -1.0, 1.0)
    elbow = math.acos(cos_e)
    if elbow_up: elbow=-elbow
    phi      = math.atan2(z_eff,r)
    shoulder = phi-math.atan2(L2*math.sin(elbow), L1+L2*math.cos(elbow))
    return yaw,shoulder,elbow

def forward_kinematics_world(yaw, shoulder, elbow, wrist, chassis_pos):
    am=get_arm_mount(chassis_pos); p0=am.copy()
    pS=p0+np.array([0.,0.,BASE_HEIGHT])
    p1=pS+np.array([L1*math.cos(shoulder)*math.cos(yaw),
                     L1*math.cos(shoulder)*math.sin(yaw),
                     L1*math.sin(shoulder)])
    t1=shoulder+elbow
    p2=p1+np.array([L2*math.cos(t1)*math.cos(yaw),
                     L2*math.cos(t1)*math.sin(yaw),
                     L2*math.sin(t1)])
    t2=t1+wrist
    p3=p2+np.array([L3*math.cos(t2)*math.cos(yaw),
                     L3*math.cos(t2)*math.sin(yaw),
                     L3*math.sin(t2)])
    return np.vstack([p0,pS,p1,p2,p3])

def make_finger_polyline(hinge, tdir, inward_dir, close_angle):
    fdir=unit(math.cos(close_angle)*tdir+math.sin(close_angle)*inward_dir)
    tip=hinge+FINGER_LEN*fdir
    cd=np.cross(fdir,tdir)
    if np.linalg.norm(cd)<1e-6: cd=np.cross(fdir,np.array([0.,0.,1.]))
    cd=unit(cd); ow=-inward_dir; cap=[]
    for ang in np.linspace(-math.pi/2, math.pi/2, TIP_ARC_PTS):
        cap.append(tip+TIP_ARC_RADIUS*(math.cos(ang)*cd+0.25*math.sin(ang)*ow))
    return np.vstack([hinge,tip,np.array(cap)])


# ============================================================
# Main window
# ============================================================
class IKWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("PAUL Arm IK  â€”  180Â° Servo Limits")

        root = QVBoxLayout()
        self.setLayout(root)

        # â”€â”€ 3D view â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        self.view = gl.GLViewWidget()
        self.view.setCameraPosition(distance=800, elevation=18, azimuth=40)
        root.addWidget(self.view, stretch=1)
        grid=gl.GLGridItem(); grid.scale(50,50,1); self.view.addItem(grid)

        # â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        self.chassis_pos        = np.array([0.,0.], dtype=float)
        self.chassis_target_pos = np.array([0.,0.], dtype=float)
        self.chassis_speed      = 0.05

        # Start at home pose so the arm is immediately in a legal position
        self.current_angles = list(HOME_ANGLES)
        self.target_angles  = list(HOME_ANGLES)
        self.via_angles     = None
        self.target_xyz     = np.array([200.,0.,CHASSIS["Lz"]+150.], dtype=float)
        self.grip = self.grip_target = 1.0

        # IDLE | REPOSITIONING | ARM_TO_VIA | ARM_TO_TARGET
        self.state = "IDLE"

        self.obstacles = []

        # â”€â”€ Chassis meshes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        self.chassis_mesh = make_box_mesh(
            [0,0,CHASSIS["Lz"]/2], (CHASSIS["Lx"],CHASSIS["Ly"],CHASSIS["Lz"]),
            color=(0.35,0.35,0.38,0.75))
        self.view.addItem(self.chassis_mesh)

        self.turret_mesh = make_cylinder_mesh(
            [0,0,CHASSIS["Lz"]], TURRET["radius"], TURRET["height"],
            slices=40, color=(0.5,0.5,0.55,0.8))
        self.view.addItem(self.turret_mesh)

        self.turret_dz_mesh = make_cylinder_mesh(
            [0,0,CHASSIS["Lz"]], TURRET["radius"]+CYL_MARGIN, TURRET["height"]+2*CYL_MARGIN,
            slices=40, color=(1.0,0.2,0.2,0.13))
        self.view.addItem(self.turret_dz_mesh)

        # â”€â”€ Arm / target plots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        self.arm_plot    = gl.GLLinePlotItem(width=5, color=(0.2,0.7,1.0,1.0))
        self.target_plot = gl.GLScatterPlotItem(size=14, color=(1.0,0.25,0.25,1.0))
        self.mount_plot  = gl.GLScatterPlotItem(size=8,  color=(1.0,1.0,0.0,1.0))
        self.finger_a    = gl.GLLinePlotItem(width=3, color=(0.9,0.9,0.9,1.0))
        self.finger_b    = gl.GLLinePlotItem(width=3, color=(0.9,0.9,0.9,1.0))
        for item in [self.arm_plot,self.target_plot,self.mount_plot,
                     self.finger_a,self.finger_b]:
            self.view.addItem(item)

        # â”€â”€ Status bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        self.status_label = QLabel("Status: IDLE")
        self.status_label.setStyleSheet(
            "font-weight:bold; padding:4px; font-size:12px;")
        root.addWidget(self.status_label)

        # â”€â”€ Joint readout panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Dark panel so the coloured text pops
        joint_frame = QFrame()
        joint_frame.setStyleSheet(
            "background:#1a1a2e; border-radius:4px; padding:2px;")
        jrow = QHBoxLayout(joint_frame)
        jrow.setContentsMargins(6,4,6,4)

        jrow.addWidget(self._make_joint_header())

        self._jlabels = {}   # name â†’ QLabel for the value
        self._jbars   = {}   # name â†’ QLabel used as a thin coloured bar
        for name, home_deg in [("yaw",0), ("shoulder",45), ("elbow",-90), ("wrist",45)]:
            col = QVBoxLayout()
            col.setSpacing(1)
            title = QLabel(name.upper())
            title.setStyleSheet("color:#aaaaaa; font-size:10px;")
            val   = QLabel("  0.0Â°")
            val.setStyleSheet("color:#80ff80; font-size:13px; font-weight:bold;")
            limit_lo, limit_hi = JOINT_LIMITS[name]
            range_lbl = QLabel(f"[{math.degrees(limit_lo):.0f}Â° â€¦ {math.degrees(limit_hi):.0f}Â°]")
            range_lbl.setStyleSheet("color:#666688; font-size:9px;")
            bar = QLabel()
            bar.setFixedHeight(4)
            bar.setStyleSheet("background:#80ff80; border-radius:2px;")
            col.addWidget(title)
            col.addWidget(val)
            col.addWidget(range_lbl)
            col.addWidget(bar)
            self._jlabels[name] = val
            self._jbars[name]   = bar
            jrow.addLayout(col)

        root.addWidget(joint_frame)

        # â”€â”€ Target inputs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        r1 = QHBoxLayout()
        self.x_in = QLineEdit("200"); self.y_in = QLineEdit("0")
        self.z_in = QLineEdit(str(int(CHASSIS["Lz"]+150)))
        for lbl,w in [("Target X:",self.x_in),("  Y:",self.y_in),("  Z:",self.z_in)]:
            r1.addWidget(QLabel(lbl)); r1.addWidget(w)
        btn_move = QPushButton("â–¶  Move Arm")
        btn_move.setStyleSheet("font-weight:bold; padding:4px 12px;")
        btn_move.clicked.connect(self.move_to_target)
        r1.addWidget(btn_move)
        btn_home = QPushButton("ðŸ   Home")
        btn_home.setStyleSheet("padding:4px 10px;")
        btn_home.setToolTip("Return all joints to their centre (home) position")
        btn_home.clicked.connect(self._go_home)
        r1.addWidget(btn_home)
        root.addLayout(r1)

        # â”€â”€ Obstacle controls â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        r2 = QHBoxLayout()
        r2.addWidget(QLabel("Obstacle:"))
        r2.addWidget(QLabel("X:"))
        self.obs_x_in = QLineEdit("150"); self.obs_x_in.setMaximumWidth(55)
        r2.addWidget(self.obs_x_in)
        r2.addWidget(QLabel("Y:"))
        self.obs_y_in = QLineEdit("0");   self.obs_y_in.setMaximumWidth(55)
        r2.addWidget(self.obs_y_in)
        r2.addWidget(QLabel("Z:"))
        self.obs_z_in = QLineEdit(str(int(CHASSIS["Lz"]+60)))
        self.obs_z_in.setMaximumWidth(55)
        r2.addWidget(self.obs_z_in)
        btn_add = QPushButton("âž•  Add Obstacle")
        btn_add.setStyleSheet("font-weight:bold; padding:4px 10px;")
        btn_add.clicked.connect(self._add_obstacle)
        r2.addWidget(btn_add)
        btn_clear = QPushButton("ðŸ—‘  Clear")
        btn_clear.clicked.connect(self._clear_obstacles)
        r2.addWidget(btn_clear)
        r2.addStretch(1)
        root.addLayout(r2)

        # â”€â”€ Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        r3 = QHBoxLayout()
        self.cb_elbow_up   = QCheckBox("Prefer Elbow Up"); self.cb_elbow_up.setChecked(True)
        self.cb_auto_pinch = QCheckBox("Auto Pinch");      self.cb_auto_pinch.setChecked(True)
        self.cb_level      = QCheckBox("Keep Tool Level"); self.cb_level.setChecked(True)
        for w in [self.cb_elbow_up, self.cb_auto_pinch, self.cb_level]: r3.addWidget(w)
        r3.addStretch(1)
        root.addLayout(r3)

        self.timer = QTimer()
        self.timer.timeout.connect(self._tick)
        self.timer.start(20)

        # Draw the home pose immediately
        self._refresh_draw()

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Small header for joint panel
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _make_joint_header(self):
        lbl = QLabel("JOINTS")
        lbl.setStyleSheet(
            "color:#aaaaaa; font-size:10px; font-weight:bold;"
            "padding-right:8px;")
        return lbl

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Home button
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _go_home(self):
        self.target_angles = list(HOME_ANGLES)
        self.via_angles    = None
        self.state         = "ARM_TO_TARGET"
        self._status("ðŸ  Returning to home position.")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Obstacle helpers
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _add_obstacle(self):
        try:
            ox=float(self.obs_x_in.text())
            oy=float(self.obs_y_in.text())
            oz=float(self.obs_z_in.text())
        except Exception:
            self._status("âš ï¸  Invalid obstacle coordinates."); return
        center=np.array([ox,oy,oz],dtype=float)
        size=OBS_HALF*2.0
        mesh=make_box_mesh(center,size,color=(0.1,0.45,1.0,1.0))
        self.view.addItem(mesh)
        self.obstacles.append({"center":center.copy(),"size":size.copy(),"mesh":mesh})
        self._status(f"Obstacle added at ({ox:.0f}, {oy:.0f}, {oz:.0f}) â€” press â–¶ to replan.")

    def _clear_obstacles(self):
        for o in self.obstacles: self.view.removeItem(o["mesh"])
        self.obstacles.clear()
        self._status("Obstacles cleared.")

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Chassis sync
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _sync_chassis(self):
        T=QMatrix4x4()
        T.translate(float(self.chassis_pos[0]),float(self.chassis_pos[1]),0.)
        for m in [self.chassis_mesh,self.turret_mesh,self.turret_dz_mesh]:
            m.setTransform(T)

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # IK helpers
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _try_ik(self, tx_w, ty_w, tz_w, phi, elbow_up, cp):
        am=get_arm_mount(cp)
        tx,ty,tz=tx_w-am[0], ty_w-am[1], tz_w-am[2]
        yaw0=math.atan2(ty,tx)
        rxy=(L3+CLAW_CENTER_OFFSET)*math.cos(phi)
        rz =(L3+CLAW_CENTER_OFFSET)*math.sin(phi)
        sol=solve_ik_wrist_base(tx-rxy*math.cos(yaw0),
                                 ty-rxy*math.sin(yaw0),
                                 tz-rz, elbow_up)
        if sol is None: return None
        yaw,shoulder,elbow=sol
        wrist=phi-(shoulder+elbow)
        if not within_limits(yaw,shoulder,elbow,wrist): return None
        pts=forward_kinematics_world(yaw,shoulder,elbow,wrist,cp)
        if pose_collides(pts,cp,self.obstacles): return None
        return [yaw,shoulder,elbow,wrist]

    def _best_ik(self, tx_w, ty_w, tz_w, phi, prefer_up, cp):
        for eu in [prefer_up, not prefer_up]:
            sol=self._try_ik(tx_w,ty_w,tz_w,phi,eu,cp)
            if sol is not None: return sol
        return None

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Via-point search
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _find_via(self, target_ang, cp):
        jl=JOINT_LIMITS
        best_via=None; best_cost=float("inf")
        for yaw in np.linspace(jl["yaw"][0],     jl["yaw"][1],     VIA_YAW_N):
          for sh in np.linspace(jl["shoulder"][0],jl["shoulder"][1],VIA_SHOULDER_N):
            for el in np.linspace(jl["elbow"][0], jl["elbow"][1],   VIA_ELBOW_N):
                wr=-(sh+el)
                if not within_limits(yaw,sh,el,wr): continue
                pts=forward_kinematics_world(yaw,sh,el,wr,cp)
                if pose_collides(pts,cp,self.obstacles): continue
                via=[yaw,sh,el,wr]
                if path_collides(self.current_angles,via,cp,self.obstacles): continue
                if path_collides(via,target_ang,       cp,self.obstacles): continue
                cost=(sum(abs(via[i]-self.current_angles[i]) for i in range(4))+
                      sum(abs(via[i]-target_ang[i])          for i in range(4)))
                if cost<best_cost: best_cost=cost; best_via=via
        return best_via

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Chassis reposition search
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _find_reposition(self, tx_w, ty_w, tz_w, phi, prefer_up):
        dx=self.chassis_pos[0]-tx_w; dy=self.chassis_pos[1]-ty_w
        retreat=math.atan2(dy,dx)
        best_sol=None; best_cp=None; best_d=float("inf")
        for ret in np.linspace(80,550,18):
            for swp in np.linspace(-80,80,13):
                ang=retreat+math.radians(swp)
                cp=np.array([tx_w+ret*math.cos(ang), ty_w+ret*math.sin(ang)])
                sol=self._best_ik(tx_w,ty_w,tz_w,phi,prefer_up,cp)
                if sol is not None:
                    d=float(np.linalg.norm(cp-self.chassis_pos))
                    if d<best_d: best_d=d; best_sol=sol; best_cp=cp.copy()
        return best_cp, best_sol

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Main planner
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def move_to_target(self):
        try:
            x=float(self.x_in.text()); y=float(self.y_in.text()); z=float(self.z_in.text())
        except Exception: return

        self.target_xyz=np.array([x,y,z],dtype=float)
        self.target_plot.setData(pos=np.array([[x,y,z]]))

        phi=0.0; pref_up=self.cb_elbow_up.isChecked(); cp=self.chassis_pos

        # 1. Direct
        sol=self._best_ik(x,y,z,phi,pref_up,cp)
        if sol is not None:
            if not path_collides(self.current_angles,sol,cp,self.obstacles):
                self._commit(sol,None,None); self._status("Direct path â€” moving arm."); return
            via=self._find_via(sol,cp)
            if via is not None:
                self._commit(sol,via,None); self._status("Path blocked â€” detouring."); return

        # 2. Reposition
        self._status("Searching for repositionâ€¦")
        new_cp,new_sol=self._find_reposition(x,y,z,phi,pref_up)
        if new_sol is not None:
            if not path_collides(self.current_angles,new_sol,new_cp,self.obstacles):
                self._commit(new_sol,None,new_cp)
                d=np.linalg.norm(new_cp-cp)
                self._status(f"Repositioning chassis {d:.0f} mm â€” arm will follow."); return
            via=self._find_via(new_sol,new_cp)
            if via is not None:
                self._commit(new_sol,via,new_cp)
                d=np.linalg.norm(new_cp-cp)
                self._status(f"Reposition {d:.0f} mm + detour â€” moving chassis first."); return

        self._status("âŒ No valid path found â€” target may be outside joint limits.")

    def _commit(self, target_ang, via_ang, new_cp):
        self.target_angles=target_ang; self.via_angles=via_ang
        if new_cp is not None:
            self.chassis_target_pos=new_cp; self.state="REPOSITIONING"
        else:
            self.state="ARM_TO_VIA" if via_ang is not None else "ARM_TO_TARGET"

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Animation tick
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    def _tick(self):
        if self.state=="REPOSITIONING":
            diff=self.chassis_target_pos-self.chassis_pos
            self.chassis_pos+=diff*self.chassis_speed
            self._sync_chassis()
            if np.linalg.norm(diff)<2.0:
                self.chassis_pos=self.chassis_target_pos.copy()
                self.state="ARM_TO_VIA" if self.via_angles is not None else "ARM_TO_TARGET"
                self._status("Chassis arrived â€” extending arm.")

        elif self.state=="ARM_TO_VIA":
            if self._smooth_to(self.via_angles)<0.001:
                self.via_angles=None; self.state="ARM_TO_TARGET"
                self._status("Waypoint reached â€” continuing to target.")

        elif self.state=="ARM_TO_TARGET":
            if self._smooth_to(self.target_angles)<0.001:
                self.state="IDLE"; self._status("âœ… Target reached.")

        self._refresh_draw()

    def _refresh_draw(self):
        yaw,sh,el,wr=self.current_angles
        pts=forward_kinematics_world(yaw,sh,el,wr,self.chassis_pos)
        col=pose_collides(pts,self.chassis_pos,self.obstacles)
        self.arm_plot.setData(pos=pts,
            color=(1.0,0.15,0.15,1.0) if col else (0.2,0.75,1.0,1.0))
        self.mount_plot.setData(pos=np.array([get_arm_mount(self.chassis_pos)]))

        # Claw
        tp=sh+el+wr
        tdir=unit(np.array([math.cos(tp)*math.cos(yaw),
                             math.cos(tp)*math.sin(yaw),
                             math.sin(tp)],dtype=float))
        mount=pts[-1]; cc=mount+CLAW_CENTER_OFFSET*tdir
        if self.cb_auto_pinch.isChecked():
            self.grip_target=0.0 if np.linalg.norm(cc-self.target_xyz)<=PINCH_DISTANCE_MM else 1.0
        else:
            self.grip_target=1.0
        self.grip+=(self.grip_target-self.grip)*GRIP_SMOOTH
        sdir=unit(np.array([-math.sin(yaw),math.cos(yaw),0.]))
        hs=0.5*CLAW_HINGE_SEP
        ha=mount+hs*sdir; hb=mount-hs*sdir
        ca=(1.-self.grip)*math.asin(max(0.,min(1.,hs/max(1e-6,FINGER_LEN))))
        self.finger_a.setData(pos=make_finger_polyline(ha,tdir,-sdir,ca))
        self.finger_b.setData(pos=make_finger_polyline(hb,tdir,+sdir,ca))

        # â”€â”€ Update joint readout labels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        names  = ["yaw","shoulder","elbow","wrist"]
        values = [yaw, sh, el, wr]
        for name, val in zip(names, values):
            deg      = math.degrees(val)
            fraction = joint_usage_fraction(name, val)
            style    = limit_color_style(fraction)
            lo, hi   = JOINT_LIMITS[name]
            span     = hi - lo

            # Degree label
            self._jlabels[name].setText(f"{deg:+.1f}Â°")
            self._jlabels[name].setStyleSheet(style + "font-size:13px;")

            # Bar: width proportional to how far from centre
            bar_pct = int(fraction * 100)
            if fraction >= WARN_RED:
                bar_color = "#ff3030"
            elif fraction >= WARN_YELLOW:
                bar_color = "#ffcc00"
            else:
                bar_color = "#80ff80"
            self._jbars[name].setStyleSheet(
                f"background:{bar_color}; border-radius:2px; "
                f"min-width:{bar_pct}px; max-width:{bar_pct}px;")

    def _smooth_to(self, target, speed=0.06):
        err=0.
        for i in range(4):
            d=target[i]-self.current_angles[i]
            self.current_angles[i]+=d*speed
            err+=abs(d)
        return err

    def _status(self, msg):
        self.status_label.setText(f"Status:  {msg}")


# ============================================================
if __name__ == "__main__":
    app=QApplication(sys.argv)
    win=IKWindow()
    win.resize(1050,780)
    win.show()
    sys.exit(app.exec_())
